<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>FreeRTOS实时内核指南——资源管理 | Star</title><meta name="keywords" content="freeRTOS,ESP32"><meta name="author" content="Star"><meta name="copyright" content="Star"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="FreeRTOS实时内核指南——资源管理概览多任务系统中存在一种潜在的风险。当一个任务在使用某个资源的过程中，即还没有完全结束对资源的访问时，便被切出运行态，使得资源处于非一致，不完整的状态。如果这个时候有另一个任务或者中断来访问这个资源，则会导致数据损坏或是其它相似的错误。   软件定时器简介软件定时器的作用：在指定的时间到来时执行指定的函数，或者以某个频率周期性地执行某个函数。被执行的函数叫做">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS实时内核指南——资源管理">
<meta property="og:url" content="http://wzx046.github.io/post/56/index.html">
<meta property="og:site_name" content="Star">
<meta property="og:description" content="FreeRTOS实时内核指南——资源管理概览多任务系统中存在一种潜在的风险。当一个任务在使用某个资源的过程中，即还没有完全结束对资源的访问时，便被切出运行态，使得资源处于非一致，不完整的状态。如果这个时候有另一个任务或者中断来访问这个资源，则会导致数据损坏或是其它相似的错误。   软件定时器简介软件定时器的作用：在指定的时间到来时执行指定的函数，或者以某个频率周期性地执行某个函数。被执行的函数叫做">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://wzx046.github.io/img/num/5.jpg">
<meta property="article:published_time" content="2024-03-25T01:17:00.000Z">
<meta property="article:modified_time" content="2024-04-10T14:27:33.679Z">
<meta property="article:author" content="Star">
<meta property="article:tag" content="freeRTOS">
<meta property="article:tag" content="ESP32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wzx046.github.io/img/num/5.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://wzx046.github.io/post/56/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'FreeRTOS实时内核指南——资源管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-10 22:27:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/archive.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Star</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">FreeRTOS实时内核指南——资源管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-25T01:17:00.000Z" title="发表于 2024-03-25 09:17:00">2024-03-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-10T14:27:33.679Z" title="更新于 2024-04-10 22:27:33">2024-04-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ESPIDF/">ESPIDF</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="FreeRTOS实时内核指南——资源管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="FreeRTOS实时内核指南——资源管理"><a href="#FreeRTOS实时内核指南——资源管理" class="headerlink" title="FreeRTOS实时内核指南——资源管理"></a>FreeRTOS实时内核指南——资源管理</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>多任务系统中存在一种潜在的风险。当一个任务在使用某个资源的过程中，即还没有完全结束对资源的访问时，便被切出运行态，使得资源处于非一致，不完整的状态。如果这个时候有另一个任务或者中断来访问这个资源，则会导致数据损坏或是其它相似的错误。  </p>
<h2 id="软件定时器"><a href="#软件定时器" class="headerlink" title="软件定时器"></a>软件定时器</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>软件定时器的作用：在指定的时间到来时执行指定的函数，或者以某个频率周期性地执行某个函数。被执行的函数叫做软件定时器回调函数。<br>软件定时器由 FreeRTOS 内核实现，<strong>不需要硬件支持</strong>。软件定时器只有在<strong>软件定时器回调函数被调用时才需要占用CPU时间</strong>。<br><strong>提醒：软件定时器回调函数是在软件定时器任务中被执行的，这个任务是在<code>vTaskStartScheduler()</code>函数内部由内核自动创建的。不要在回调函数中使用一些导致任务阻塞的函数或代码，例如<code>vTaskDelay()</code>，否则会导致 FreeRTOS 后台任务进入到阻塞状态。而且应该尽量让定时器回调函代码简洁高效快速执行。</strong>  </p>
<h3 id="创建软件定时器"><a href="#创建软件定时器" class="headerlink" title="创建软件定时器"></a>创建软件定时器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TimerHandle_t xTimerCreate(  const char * const pcTimerName,</span><br><span class="line">                             TickType_t xTimerPeriodInTicks,</span><br><span class="line">                             UBaseType_t uxAutoReload,</span><br><span class="line">                             void * pvTimerID,</span><br><span class="line">                             TimerCallbackFunction_t pxCallbackFunction );</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>pcTimerName</code></td>
<td>A text name that is assigned to the timer.  This is done purely to assist debugging.  The kernel itself only ever references a timer by its handle, and never by its name.</td>
</tr>
<tr>
<td><code>xTimerPeriodInTicks</code></td>
<td>The timer period.  The time is defined in tick periods so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds.  For example, if the timer must expire after 100 ticks, then xTimerPeriodInTicks should be set to 100.Alternatively, if the timer must expire after 500ms, then xPeriod can be set to ( 500 &#x2F; portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.  Time timer period must be greater than 0.</td>
</tr>
<tr>
<td><code>uxAutoReload</code></td>
<td>If uxAutoReload is set to pdTRUE then the timer will expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter.If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and enter the dormant state after it expires.</td>
</tr>
<tr>
<td><code>pvTimerID</code></td>
<td>An identifier that is assigned to the timer being created.Typically this would be used in the timer callback function to identify which timer expired when the same callback function is assigned to more than one timer.</td>
</tr>
<tr>
<td><code>pxCallbackFunction</code></td>
<td>he function to call when the timer expires.Callback functions must have the prototype defined by TimerCallbackFunction_t,which is “void vCallbackFunction( TimerHandle_t xTimer );”.</td>
</tr>
<tr>
<td><code>return</code></td>
<td>If the timer is successfully created then a handle to the newly created timer is returned.  If the timer cannot be created because there is insufficient FreeRTOS heap remaining to allocate the timer structures then NULL is returned.</td>
</tr>
</tbody></table>
<p>当<code>uxAutoReload</code> 参数为 <code>pdFALSE</code> 时，回调函数只执行一次；参数为 <code>pdTRUE</code> 时，函数会不断重复运行。  </p>
<h3 id="重置定时器"><a href="#重置定时器" class="headerlink" title="重置定时器"></a>重置定时器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define xTimerReset( xTimer, xTicksToWait ) \</span><br><span class="line">    xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) )</span><br></pre></td></tr></table></figure>
<p>该函数可以类似于看门狗中的喂狗操作。  </p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;freertos/timers.h&quot;</span><br><span class="line"></span><br><span class="line">void timerCallback(TimerHandle_t xTimer)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void app_main(void)</span><br><span class="line">&#123;</span><br><span class="line">    TimerHandle_t timer1;</span><br><span class="line">    timer1 = xTimerCreate(&quot;timer1&quot;, pdMS_TO_TICKS(1000), pdTRUE, 0, timerCallback);</span><br><span class="line">    xTimerStart(timer1, 0);</span><br><span class="line">    vTaskDelay(5000/portTICK_PERIOD_MS);</span><br><span class="line">    xTimerStop(timer1, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>访问一个被多任务共享，或是被任务与中断共享的资源时，需要采用“互斥”技术以保证数据在任何时候都保持一致性。这样做的目的是要确保任务从开始访问资源就具有排它性，直至这个资源又恢复到完整状态。<br>FreeRTOS 提供了多种特性用以实现互斥，但是最好的互斥方法（如果可能的话，任何时候都当如此）还是通过精心设计应用程序，尽量不要共享资源，或者是每个资源都通过单任务访问。  </p>
<h3 id="临界区与挂起调度器"><a href="#临界区与挂起调度器" class="headerlink" title="临界区与挂起调度器"></a>临界区与挂起调度器</h3><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>临界区是提供互斥功能的一种非常原始的实现方法。临界区的工作仅仅是简单地把中断全部关掉，或是关掉优先级在 <code>configMAX_SYSCAL_INTERRUPT_PRIORITY</code> 及以下的中断——依赖于具体使用的 FreeRTOS 移植。抢占式上下文切换只可能在某个中断中完成，所以调用 <code>taskENTER_CRITICAL()</code>的任务可以在中断关闭的时段一直保持运行态，直到退出临界区。<br>临界区必须只具有很短的时间，否则会反过来影响中断响应时间。临界区嵌套是安全的，因为内核有维护一个嵌套深度计数。临界区只会在嵌套深度为 0 时才会真正退出。  </p>
<h4 id="挂起-锁定-调度器"><a href="#挂起-锁定-调度器" class="headerlink" title="挂起(锁定)调度器"></a>挂起(锁定)调度器</h4><p>可以通过挂起调度器来创建临界区。挂起调度器有些时候也被称为锁定调度器。<br>临界区保护一段代码区间不被其它任务或中断打断。由挂起调度器实现的临界区只可以保护一段代码区间不被其它任务打断，因为这种方式下，中断是使能的。<br>如果一个临界区太长而不适合简单地关中断来实现，可以考虑采用挂起调度器的方式。但是唤醒 (resuming, or un-suspending) 调度器却是一个相对较长的操作。所以评估哪种是最佳方式需要结合实际情况。  </p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量可以是<strong>二进制信号量</strong>也可以是<strong>计数信号量</strong>。二进制信号量可以看作是计数信号量的一种特殊形式，一般用于对共享资源的访问，信号量的初始值设为 1。在计数信号量的情况下，计数值通常被实现为一个简单的无符号整数。当发送一个计数信号量时，增加信号量的值。当获取一个信号量时，则计数值递减。在任务获取信号量时，如果该值为0，则任务被阻塞，直到有其他任务或中断服务程序发送该信号量，该任务才退出阻塞状态进入就绪状态，如果此时该任务是就绪表中优先级最该的任务则获得运行的机会。<strong>因此，可以使用信号量在任务之间发送信号，表示某事已准备就绪。</strong>  </p>
<h4 id="二进制信号量"><a href="#二进制信号量" class="headerlink" title="二进制信号量"></a>二进制信号量</h4><p>二进制信号量创建以后为空状态，在获取信号量之前首先要释放信号量。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;freertos/semphr.h&quot;</span><br><span class="line"></span><br><span class="line">SemaphoreHandle_t semphrHandle;</span><br><span class="line">int iCount = 0;</span><br><span class="line"></span><br><span class="line">void task1(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        xSemaphoreTake(semphrHandle, portMAX_DELAY);  // 锁住信号量</span><br><span class="line">        iCount++;</span><br><span class="line">        vTaskDelay(2000/portTICK_PERIOD_MS);</span><br><span class="line">        printf(&quot;task1 iCount = %d\n&quot;, iCount);</span><br><span class="line">        xSemaphoreGive(semphrHandle);  // 释放信号量</span><br><span class="line">        vTaskDelay(1/portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void task2(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        xSemaphoreTake(semphrHandle, portMAX_DELAY);  // 锁住信号量</span><br><span class="line">        iCount++;</span><br><span class="line">        vTaskDelay(2000/portTICK_PERIOD_MS);</span><br><span class="line">        printf(&quot;task2 iCount = %d\n&quot;, iCount);</span><br><span class="line">        xSemaphoreGive(semphrHandle);  // 释放信号量</span><br><span class="line">        vTaskDelay(1/portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void app_main(void)</span><br><span class="line">&#123;</span><br><span class="line">    semphrHandle = xSemaphoreCreateBinary();  // 创建二进制信号量</span><br><span class="line">    xSemaphoreGive(semphrHandle);  // 释放信号量</span><br><span class="line">    xTaskCreate(task1, &quot;task1&quot;, 1024*4, NULL, 1, NULL);</span><br><span class="line">    xTaskCreate(task2, &quot;task2&quot;, 1024*4, NULL, 1, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计数型信号量"><a href="#计数型信号量" class="headerlink" title="计数型信号量"></a>计数型信号量</h4><p>当某个事件发生时，任务或者中断释放一个信号量，即信号量的值加一；当处理事件时，处理任务会消费一个信号量，即信号量的值减一；信号量的计数值表示还有多少个事件待处理。<strong>计数型信号量可以被多个任务进行操作，但是对任务的数量有限制。</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;freertos/semphr.h&quot;</span><br><span class="line"></span><br><span class="line">SemaphoreHandle_t semphrHandle;</span><br><span class="line"></span><br><span class="line">void task1(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    int emptySpace = 0;</span><br><span class="line">    BaseType_t iResult;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        emptySpace = uxSemaphoreGetCount(semphrHandle);  // 获取信号量数目</span><br><span class="line">        printf(&quot;emptySpace = %d\n&quot;, emptySpace);</span><br><span class="line">        iResult = xSemaphoreTake(semphrHandle, 0);  // 获取信号量，成功获取后减一</span><br><span class="line">        if(iResult == pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;1 car in\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;no space\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(1000));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void task2(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(6000));</span><br><span class="line">        xSemaphoreGive(semphrHandle);  // 释放信号量,数目加一</span><br><span class="line">        printf(&quot;1 car out \n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void app_main(void)</span><br><span class="line">&#123;</span><br><span class="line">    semphrHandle = xSemaphoreCreateCounting(5, 5);  // 创建计数型信号量  最大值5 初始值5</span><br><span class="line">    xTaskCreate(task1, &quot;task1&quot;, 1024*4, NULL, 1, NULL);</span><br><span class="line">    xTaskCreate(task2, &quot;task2&quot;, 1024*4, NULL, 1, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>互斥量是一种特殊的二值信号量，用于控制在两个或多个任务间访问共享资源。单词 MUTEX (互斥量)源于“MUTual EXclusion”。<br>在用于互斥的场合，互斥量从概念上可看作是与共享资源关联的令牌。一个任务想要合法地访问资源，其必须先成功地得到(Take)该资源对应的令牌(成为令牌持有者)。当令牌持有者完成资源使用，其必须马上归还(Give)令牌。只有归还了令牌，其它任务才可能成功持有，也才可能安全地访问该共享资源。一个任务除非持有了令牌，否则不允许访问共享资源。  </p>
<h4 id="信号量与互斥量之间的区别"><a href="#信号量与互斥量之间的区别" class="headerlink" title="信号量与互斥量之间的区别"></a>信号量与互斥量之间的区别</h4><ol>
<li>互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。  <ul>
<li>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是<strong>无序</strong>的。</li>
<li>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的<strong>有序</strong>访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</li>
</ul>
</li>
<li>互斥量值只能为 0&#x2F;1，信号量值可以为非负整数。<ul>
<li>一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为二进制信号量时，也可以完成一个资源的互斥访问。</li>
</ul>
</li>
<li>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</li>
</ol>
<blockquote>
<p>互斥量是管理临界资源的一种有效手段， 因为互斥量是独占的， 所以在<strong>一个时刻只允许一个线程占有互斥量</strong>，利用这个性质来实现共享资源的互斥量保护，任何时刻只允许一个线程获得互斥量对象，未能够获得互斥量对象的线程被挂起在该互斥量的等待线程队列上，这一点和二进制信号量是相同的，但<strong>互斥量有所有者的概念</strong>，高优先级的任务可以在获取互斥量时通过对比所有者的优先级是否高于自己来决定是否提升所有者的优先级。所以互斥量可以有效对付<em><strong>优先级反转</strong></em>的问题。  </p>
</blockquote>
<blockquote>
<p>信号量是用来解决线程同步和互斥的通用工具， 和互斥量类似， 信号量也可以用作自于资源互斥访问， 但信号量<strong>没有所有者</strong>的概念，在应用上比互斥量更广泛，信号量比较简单,不能解决优先级反转问题，但信号量是一种轻量级的对象，比互斥量小巧，灵活，因此在很多对互斥要求不严格的的系统中，经常使用信号量来管理互斥资源。</p>
</blockquote>
<h4 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h4><p>优先级反转，是指在使用信号量时，可能会出现的这样一种不合理的现象，即<strong>高优先级任务被低优先级任务阻塞，导致高优先级任务迟迟得不到调度。但其他中等优先级的任务却能抢到CPU资源</strong>。从现象上来看，好像是中优先级的任务比高优先级任务具有更高的优先权。  </p>
<p>一个具体的例子：假定一个进程中有三个线程Thread1（高）、Thread2（中）和Thread3（低），考虑下图的执行情况。<br><img src="/img/postpages/freeRTOS/3.png"> </p>
<ul>
<li>T0 时刻，Thread3 运行，并获得同步资源 SYNCH1；</li>
<li>T1 时刻，Thread2 开始运行，由于优先级高于 Thread3，Thread3 被抢占（未释放同步资源 SYNCH1），Thread2 被调度执行；</li>
<li>T2 时刻，Thread1 抢占 Thread2；</li>
<li>T3 时刻，Thread1 需要同步资源 SYNCH1，但 SYNCH1 被更低优先级的 Thread3 所拥有，Thread1 被挂起等待该资源；</li>
<li>而此时线程 Thread2 和 Thread3 都处于可运行状态，Thread2 的优先级大于 Thread3 的优先级，Thread2 被调度执行。最终的结果是高优先级的 Thread1 迟迟无法得到调度，而中优先级的 Thread2 却能抢到 CPU 资源。</li>
</ul>
<h4 id="优先级继承"><a href="#优先级继承" class="headerlink" title="优先级继承"></a>优先级继承</h4><p>优先级继承是最小化优先级反转负面影响的一种方案,其并不能修正优先级反转带来的问题，仅仅是减小优先级反转的影响。优先级继承使得系统行为的数学分析更为复杂，所以如果可以避免的话，并不建议系统实现对优先级继承有所依赖。<br><strong>优先级继承暂时地将互斥量持有者的优先级提升至所有等待此互斥量的任务所具有的最高优先级。持有互斥量的低优先级任务”继承”了等待互斥量的任务的优先级。互斥量持有者在归还互斥量时，优先级会自动设置为其原来的优先级。</strong><br>由于最好是优先考虑避免优先级反转，并且因为 FreeRTOS 本身是面向内存有限的微控制器，所以只实现了最基本的互斥量的优先级继承机制，这种实现假定一个任务在任意时刻只会持有一个互斥量。  </p>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;freertos/semphr.h&quot;</span><br><span class="line"></span><br><span class="line">SemaphoreHandle_t mutexHandle;</span><br><span class="line"></span><br><span class="line">void task1(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t ret;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;task1 begin\n&quot;);</span><br><span class="line">        ret = xSemaphoreTake(mutexHandle, 1000);  // 获取互斥量，并且继承task3优先级</span><br><span class="line">        if(ret == pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;task1 take\n&quot;);</span><br><span class="line">            for(int i=0;i&lt;50;i++)  // 长时间抢占</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;task1 i = %d\n&quot;, i);</span><br><span class="line">                vTaskDelay(pdMS_TO_TICKS(1000));</span><br><span class="line">            &#125;</span><br><span class="line">            xSemaphoreGive(mutexHandle);</span><br><span class="line">            printf(&quot;task1 give\n&quot;);</span><br><span class="line">            vTaskDelay(pdMS_TO_TICKS(5000));</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;task1 didn&#x27;t take\n&quot;);</span><br><span class="line">            vTaskDelay(pdMS_TO_TICKS(1000));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void task2(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;task2 begin\n&quot;);</span><br><span class="line">    vTaskDelay(pdMS_TO_TICKS(1000));  // 阻塞自己，让task1运行</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        ;  // 只有比task2优先级更高才能抢占</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void task3(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    // 优先级最高</span><br><span class="line">    BaseType_t ret;</span><br><span class="line">    printf(&quot;task3 begin\n&quot;);</span><br><span class="line">    vTaskDelay(pdMS_TO_TICKS(1000));  // 阻塞自己，让task1运行</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = xSemaphoreTake(mutexHandle, 1000);  // 等待task1</span><br><span class="line">        if(ret == pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;task3 take\n&quot;);</span><br><span class="line">            for(int i=0;i&lt;10;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;task3 i = %d\n&quot;, i);</span><br><span class="line">                vTaskDelay(pdMS_TO_TICKS(1000));</span><br><span class="line">            &#125;</span><br><span class="line">            xSemaphoreGive(mutexHandle);</span><br><span class="line">            printf(&quot;task3 give\n&quot;);</span><br><span class="line">            vTaskDelay(pdMS_TO_TICKS(5000));</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;task3 didn&#x27;t take\n&quot;);</span><br><span class="line">            vTaskDelay(pdMS_TO_TICKS(1000));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void app_main(void)</span><br><span class="line">&#123;</span><br><span class="line">    mutexHandle = xSemaphoreCreateMutex();  // 创建互斥量</span><br><span class="line">    // mutexHandle = xSemaphoreCreateBinary(); // 创建二进制信号量</span><br><span class="line">    vTaskSuspendAll();  // 挂起所有任务</span><br><span class="line">    xTaskCreatePinnedToCore(task1,&quot;task1&quot;,1024*5,NULL,1,NULL,0);</span><br><span class="line">    xTaskCreatePinnedToCore(task2,&quot;task2&quot;,1024*5,NULL,2,NULL,0);</span><br><span class="line">    xTaskCreatePinnedToCore(task3,&quot;task3&quot;,1024*5,NULL,3,NULL,0);</span><br><span class="line">    xTaskResumeAll();   // 恢复所有任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://wzx046.github.io">Star</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://wzx046.github.io/post/56/">http://wzx046.github.io/post/56/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://wzx046.github.io" target="_blank">Star</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/freeRTOS/">freeRTOS</a><a class="post-meta__tags" href="/tags/ESP32/">ESP32</a></div><div class="post_share"><div class="social-share" data-image="/img/num/5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/57/"><img class="prev-cover" src="/img/num/6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ZVS电路设计</div></div></a></div><div class="next-post pull-right"><a href="/post/55/"><img class="next-cover" src="/img/num/4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">INA199 &amp; ADS1115 &amp; TL431 硬件设计指南</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/51/" title="FreeRTOS实时内核指南——任务管理"><img class="cover" src="/img/num/10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-07</div><div class="title">FreeRTOS实时内核指南——任务管理</div></div></a></div><div><a href="/post/53/" title="FreeRTOS实时内核指南——队列管理"><img class="cover" src="/img/num/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-06</div><div class="title">FreeRTOS实时内核指南——队列管理</div></div></a></div><div><a href="/post/52/" title="ESPIDF-系统启动流程"><img class="cover" src="/img/num/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-08</div><div class="title">ESPIDF-系统启动流程</div></div></a></div><div><a href="/post/0/" title="ESP32上的FreeRTOS学习"><img class="cover" src="/img/num/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-17</div><div class="title">ESP32上的FreeRTOS学习</div></div></a></div><div><a href="/post/17/" title="ESP32上的FreeRTOS学习(2)"><img class="cover" src="/img/num/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-25</div><div class="title">ESP32上的FreeRTOS学习(2)</div></div></a></div><div><a href="/post/18/" title="ESP32上的FreeRTOS学习(3)"><img class="cover" src="/img/num/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-27</div><div class="title">ESP32上的FreeRTOS学习(3)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Star</div><div class="author-info__description">摸鱼ing</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/wzx046"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欸嘿~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#FreeRTOS%E5%AE%9E%E6%97%B6%E5%86%85%E6%A0%B8%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">FreeRTOS实时内核指南——资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-number">1.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">软件定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">创建软件定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">重置定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-number">1.3.</span> <span class="toc-text">互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%B8%8E%E6%8C%82%E8%B5%B7%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">临界区与挂起调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7-%E9%94%81%E5%AE%9A-%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">挂起(锁定)调度器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">二进制信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">计数型信号量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">互斥量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E4%BA%92%E6%96%A5%E9%87%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">信号量与互斥量之间的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">优先级反转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">优先级继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">代码示例</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/60/" title="无线充电电路测试"><img src="/img/num/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无线充电电路测试"/></a><div class="content"><a class="title" href="/post/60/" title="无线充电电路测试">无线充电电路测试</a><time datetime="2024-05-14T07:17:38.000Z" title="发表于 2024-05-14 15:17:38">2024-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/59/" title="ESP32存储器"><img src="/img/num/8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ESP32存储器"/></a><div class="content"><a class="title" href="/post/59/" title="ESP32存储器">ESP32存储器</a><time datetime="2024-05-05T12:09:39.000Z" title="发表于 2024-05-05 20:09:39">2024-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/58/" title="ESP32输出互补PWM波形中断"><img src="/img/num/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ESP32输出互补PWM波形中断"/></a><div class="content"><a class="title" href="/post/58/" title="ESP32输出互补PWM波形中断">ESP32输出互补PWM波形中断</a><time datetime="2024-04-22T12:34:54.000Z" title="发表于 2024-04-22 20:34:54">2024-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/57/" title="ZVS电路设计"><img src="/img/num/6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ZVS电路设计"/></a><div class="content"><a class="title" href="/post/57/" title="ZVS电路设计">ZVS电路设计</a><time datetime="2024-04-10T14:22:11.000Z" title="发表于 2024-04-10 22:22:11">2024-04-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/56/" title="FreeRTOS实时内核指南——资源管理"><img src="/img/num/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="FreeRTOS实时内核指南——资源管理"/></a><div class="content"><a class="title" href="/post/56/" title="FreeRTOS实时内核指南——资源管理">FreeRTOS实时内核指南——资源管理</a><time datetime="2024-03-25T01:17:00.000Z" title="发表于 2024-03-25 09:17:00">2024-03-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Star</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
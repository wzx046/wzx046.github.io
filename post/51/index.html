<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>FreeRTOS实时内核指南——任务管理 | Star</title><meta name="keywords" content="ESP32,freeRTOS"><meta name="author" content="Star"><meta name="copyright" content="Star"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="FreeRTOS实时内核指南——任务管理概览单任务与多任务 单任务系统 单任务系统的编程方式，即裸机的编程方式，这种编程方式的框架一般都是在 main() 函数中使用一个大循环，在循环中顺序的执行相应的函数以处理相应的事务，这个大循环的部分可以视为应用程序的后台，而应用程序的前台，则是各种中断的中断服务函数。因此单任务系统也叫做前后台系统。 前后台系统的实时性很差，因为大循环中函数处理的事务没有优">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS实时内核指南——任务管理">
<meta property="og:url" content="http://wzx046.github.io/post/51/index.html">
<meta property="og:site_name" content="Star">
<meta property="og:description" content="FreeRTOS实时内核指南——任务管理概览单任务与多任务 单任务系统 单任务系统的编程方式，即裸机的编程方式，这种编程方式的框架一般都是在 main() 函数中使用一个大循环，在循环中顺序的执行相应的函数以处理相应的事务，这个大循环的部分可以视为应用程序的后台，而应用程序的前台，则是各种中断的中断服务函数。因此单任务系统也叫做前后台系统。 前后台系统的实时性很差，因为大循环中函数处理的事务没有优">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://wzx046.github.io/img/num/10.jpg">
<meta property="article:published_time" content="2023-11-07T12:25:12.000Z">
<meta property="article:modified_time" content="2023-12-05T13:27:30.423Z">
<meta property="article:author" content="Star">
<meta property="article:tag" content="ESP32">
<meta property="article:tag" content="freeRTOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wzx046.github.io/img/num/10.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://wzx046.github.io/post/51/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'FreeRTOS实时内核指南——任务管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-05 21:27:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/archive.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Star</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">FreeRTOS实时内核指南——任务管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-07T12:25:12.000Z" title="发表于 2023-11-07 20:25:12">2023-11-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-05T13:27:30.423Z" title="更新于 2023-12-05 21:27:30">2023-12-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ESPIDF/">ESPIDF</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="FreeRTOS实时内核指南——任务管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="FreeRTOS实时内核指南——任务管理"><a href="#FreeRTOS实时内核指南——任务管理" class="headerlink" title="FreeRTOS实时内核指南——任务管理"></a>FreeRTOS实时内核指南——任务管理</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="单任务与多任务"><a href="#单任务与多任务" class="headerlink" title="单任务与多任务"></a>单任务与多任务</h3><ul>
<li>单任务系统<ul>
<li>单任务系统的编程方式，即裸机的编程方式，这种编程方式的框架一般都是在 main() 函数中使用一个大循环，在循环中顺序的执行相应的函数以处理相应的事务，这个大循环的部分可以视为应用程序的后台，而应用程序的前台，则是各种中断的中断服务函数。因此单任务系统也叫做<strong>前后台系统</strong>。</li>
<li>前后台系统的<strong>实时性很差</strong>，因为大循环中函数处理的事务没有优先级之分，必须是顺序地执行处理，不论待处理事务的紧急程度有多高，没轮到就只能等着，虽然中断可以处理一些紧急的事务，但是在大型嵌入式系统中，这样的单任务系统就会显得力不从心。</li>
</ul>
</li>
<li>多任务系统<ul>
<li>多任务系统的多个任务可以“同时”运行，是从宏观的角度而言的，对于单核CPU而言，CPU在同一时刻只能处理一个任务，但是多任务系统的任务调度器可以根据相关的任务调度算法，将CPU的使用权分给任务，在任务获得CPU使用权之后的极短时间（宏观角度）后，任务调度器又会将CPU的使用权分配给其他任务，如此往复，在宏观的角度看来，就像是多个任务同时运行一样。</li>
<li>多任务系统的任务具有<strong>优先级</strong>，高优先级的任务可以像中断一样抢占，抢占低优先级任务的CPU使用权；优先级相同的任务则各自轮流运行一段极短时间，从而产生“同时”运行的错觉。以上就是抢占式调度和时间片轮转调度的基本原理。在任务有了优先级的多任务系统中，用户就可以将紧急的事务放在优先级高的任务中进行处理，那么整个系统的<strong>实时性</strong>就会大大提高。</li>
</ul>
</li>
</ul>
<h3 id="软实时与硬实时"><a href="#软实时与硬实时" class="headerlink" title="软实时与硬实时"></a>软实时与硬实时</h3><p>实时嵌入式系统中的多任务与桌面电脑的多任务从概念上来讲是相似的。但实时嵌入式系统的侧重点却不同于桌面电脑，特别是当嵌入式系统期望提供“硬实时”行为的时候。  </p>
<ul>
<li>软实时：桌面电脑的输入处理可以归类为“软实时”。为了保证用户的最佳体验，计算机对每个输入的响应应当限定在一个恰当的时间范围，但是如果响应时间超出了限定范围，并不会让人觉得这台电脑无法使用。比如说，键盘操作必须在键按下后的某个时间内作出明显的提示。但如果按键提示超出了这个时间，会使得这个系统看起来响应太慢，而不致于说这台电脑不能使用。  </li>
<li>硬实时：<strong>硬实时功能必须在给定的时间限制之内完成</strong>。如果无法做到即意味着整个系统的绝对失败。汽车的安全气囊触发机制就是一个硬实时功能的例子。安全气囊在撞击发生后给定时间限制内必须弹出。如果响应时间超出了这个时间限制，会使得驾驶员受到伤害，而这原本是可以避免的。</li>
</ul>
<h2 id="任务函数"><a href="#任务函数" class="headerlink" title="任务函数"></a>任务函数</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void ATaskFunction(void *pvParameters);</span><br></pre></td></tr></table></figure>
<p><strong>其必须返回 void，而且带有一个 void 指针参数。</strong><br>每个任务都是在自己权限范围内的一个小程序。其具有程序入口，通常会运行在一个<strong>死循环</strong>中，不会退出。<strong>FreeRTOS 任务不允许以任何方式从实现函数中返回，不能 return，也不能执行到函数末尾</strong>。如果一个任务不再被需要，可以显式的将其删除。<br>一个任务函数可以用来创建若干个任务，创建出的任务均是独立的执行实例，拥有属于自己的栈空间，以及属于自己的自动变量(栈变量)，即任务函数本身定义的变量。  </p>
<h3 id="典型的任务函数结构"><a href="#典型的任务函数结构" class="headerlink" title="典型的任务函数结构"></a>典型的任务函数结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void ATaskFunction(void *Param)</span><br><span class="line">&#123;</span><br><span class="line">    /*用这个函数创建的每个任务实例都有一个属于自己的 value 变量。但如果 value 被定义为 static 这一点则不成立，这种情况下只存在一个变量，所有的任务实例将会共享这个变量。*/</span><br><span class="line">    int value = 0;</span><br><span class="line"></span><br><span class="line">    /*任务通常实现在一个死循环中*/</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        /*完成任务功能的代码将放在这里*/</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*如果任务的具体实现会跳出上面的死循环，则此任务必须在函数运行完之前删除。传入NULL参数表示删除的是当前任务*/</span><br><span class="line">    vTaskDelete(NULL); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="任务函数内的-static-变量"><a href="#任务函数内的-static-变量" class="headerlink" title="任务函数内的 static 变量"></a>任务函数内的 static 变量</h3><p>关于上面所述的任务实例共享 static 变量，在 ESPIDF 上进行了测试，代码如下。<a id="table1"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include &quot;freertos/FreeRTOS.h&quot;</span><br><span class="line">#include &quot;freertos/task.h&quot;</span><br><span class="line">#include &quot;../build/config/sdkconfig.h&quot;</span><br><span class="line"></span><br><span class="line">static const char *pcTxt1 = &quot;Task1&quot;;</span><br><span class="line">static const char *pcTxt2 = &quot;Task2&quot;;</span><br><span class="line"></span><br><span class="line">void vTask1(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    int data = 100; /*changed*/</span><br><span class="line">    char *pcTxt_task;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        pcTxt_task = (char *)pvParam;</span><br><span class="line">        if(strcmp(pcTxt1, pcTxt_task) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            data = 1;</span><br><span class="line">            printf(&quot;%s\n&quot;,pcTxt_task);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(strcmp(pcTxt2, pcTxt_task) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            if(data == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;already changed&quot;);</span><br><span class="line">            &#125;   </span><br><span class="line">            else if(data == 100)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;no change&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%s\n&quot;,pcTxt_task);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(1000 / portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void app_main(void)</span><br><span class="line">&#123;</span><br><span class="line">    TaskHandle_t MyHandle=NULL;//创造一个TaskHandle_t类型的变量;</span><br><span class="line">    xTaskCreate(vTask1,&quot;task 1&quot;,1024,(void *)pcTxt1,1,MyHandle);//创建任务函数</span><br><span class="line">    TaskHandle_t MyHandle2=NULL;//创造一个TaskHandle_t类型的变量;</span><br><span class="line">    xTaskCreate(vTask1,&quot;task 2&quot;,1024,(void *)pcTxt2,1,MyHandle2);//创建任务函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>int data</code>：此时 task 1 和 task 2 都有属于自己的<code>data</code>，在 task 1 改变值为1后，task 2 的值仍然为 100，打印的字符串是 “no change”。</li>
<li><code>static int data</code>：此时2个 task 共享<code>data</code>变量，task 1任务执行完后，task 2任务中<code>data</code>也变为1，打印的字符串是 “already changed”。</li>
</ul>
<h2 id="顶层任务状态"><a href="#顶层任务状态" class="headerlink" title="顶层任务状态"></a>顶层任务状态</h2><p>应用程序可以包含多个任务。如果运行应用程序的微控制器只有一个核(core)，那么在任意给定时间，实际上只会有一个任务被执行。这就意味着一个任务可以有一个或两个状态，即运行状态和非运行状态。我们先考虑这种最简单的模型。但请牢记这其实是过于简单，我们稍后将会看到非运行状态实际上又可划分为若干个子状态。<br>当某个任务处于运行态时，处理器就正在执行它的代码。当一个任务处于非运行态时，该任务进行休眠，它的所有状态都被妥善保存，以便在下一次调试器决定让它进入运行态时可以恢复执行。当任务恢复执行时，其将精确地从离开运行态时正准备执行的那一条指令开始执行。<br>任务从非运行态转移到运行态被称为“切换入或切入 (switched in)”或”交换入 (swapped in)”。相反，任务从运行态转移到非运行态被称为“切换出或切出 (switched out)”或“交换出 (swapped out)”。<strong>FreeRTOS 的调度器是能让任务切入切出的唯一实体。</strong>  </p>
<h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">portBASE_TYPE xTaskCreate(  pdTask_CODE pvTaskCode,</span><br><span class="line">                            const signed portCHAR * const pcName,</span><br><span class="line">                            unsigned portSHORT usStackDepth,</span><br><span class="line">                            void *pvParameters,</span><br><span class="line">                            unsigned portBASE_TYPE uxPriority,</span><br><span class="line">                            xTaskHandle *pxCreatedTask);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>pvTaskCode</code></td>
<td>任务只是永不退出的 C 函数，实现常通常是一个死循环。参数pvTaskCode 只一个指向任务的实现函数的指针（任务函数名）</td>
</tr>
<tr>
<td><code>pcName</code></td>
<td>具有描述性的任务名。只是单纯地用于辅助调试。应用程序可以通过定义常量 <code>config_MAX_TASK_NAME_LEN</code>来定义任务名的最大长度,包括’\0’结束符。如果传入的字符串长度超过了这个最大值，字符串将会自动被截断。</td>
</tr>
<tr>
<td><code>usStackDepth</code></td>
<td>当任务创建时，内核会分为每个任务分配属于任务自己的唯一状态。<code>usStackDepth</code>值用于告诉内核为它分配多大的栈空间。这个值指定的是栈空间可以保存多少个字(word)，而不是多少个字节(byte)。例如 32 位宽的栈空间，传入的<code>usStackDepth</code>值为 100，则会分配 400 字节的栈空间(100 * 4bytes)。</td>
</tr>
<tr>
<td><code>pvParameters</code></td>
<td>任务函数接受一个指向 void 的指针(void*)。<code>pvParameters</code>的值即是传递到任务中的值。上一节<a href="#table1">任务函数内的 static 变量</a>实践代码中有示例。</td>
</tr>
<tr>
<td><code>uxPriority</code></td>
<td>指定任务执行的优先级。优先级的取值范围可以从最低优先级 0 到最高优先级(configMAX_PRIORITIES – 1)。优先级号并没有上限(除了受限于采用的数据类型和系统的有效内存空间)，但最好使用实际需要的最小数值以避免内存浪费。</td>
</tr>
<tr>
<td><code>pxCreatedTask</code></td>
<td><code>pxCreatedTask</code>用于传出任务的句柄。这个句柄将在 API 调用中对该创建出来的任务进行引用，比如改变任务优先级，或者删除任务。如果应用程序中不会用到这个任务的句柄，则<code>pxCreatedTask</code>可以被设为 NULL。</td>
</tr>
<tr>
<td><code>返回值</code></td>
<td>1.<code>pdTRUE</code>:表明任务创建成功。2.<code>errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</code>:由于内存堆空间不足，FreeRTOS 无法分配足够的空间来保存任务结构数据和任务栈，因此无法创建任务。</td>
</tr>
</tbody></table>
<ul>
<li><strong>在任何时刻只可能有一个任务处于运行态。所以一个任务进入运行态后(切入)，另一个任务就会进入非运行态(切出)。</strong></li>
<li>可以在启动调度器之前先完成两个任务的创建，也可以从一个任务中创建另一个任务。</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>定义将要通过任务参数传递的字符串。定义为const，且不是在栈空间上，以保证任务执行时也有效。</strong><br>例如下面代码的<code>pcTextForTask1</code>和<code>pcTextForTask2</code>。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static const char *pcTextForTask1 = “Task 1 is running\r\n”; </span><br><span class="line">static const char *pcTextForTask2 = “Task 2 is running\t\n”;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreate( vTaskFunction, &quot;Task 1&quot;, 1000, (void*)pcTextForTask1, 1, NULL );</span><br><span class="line">    xTaskCreate( vTaskFunction, &quot;Task 2&quot;, 1000, (void*)pcTextForTask2, 1, NULL );</span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果将其定义在<code>main</code>函数里，它将存储在栈（Stack）上。根据 ESPIDF 编程指南，<code>app_main</code>函数返回后主任务将会被删除，栈上的数据会被自动释放。  </p>
<blockquote>
<p>主任务是指运行<code>app_main</code>函数的任务，主任务的堆栈大小和优先级可以在<code>menuconfig</code>中进行配置。应用程序可以用此任务来完成用户程序相关的初始化设置，比如启动其他的任务。应用程序还可以将主任务用于事件循环和其他通用活动。如果<code>app_main</code>函数返回，那么主任务将会被删除。  </p>
</blockquote>
<h2 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h2><p>应用程序在文件<code>FreeRTOSConfig.h</code>中设定的编译时配置常量<code>configMAX_PRIORITIES</code>的值，即是最多可具有的优先级数目。FreeRTOS 本身并没有限定这个常量的最大值，但这个值越大，则内核花销的内存空间就越多。所以总是建议将此常量设为能够用到的最小值。<br><strong>调度器保证总是在所有可运行的任务中选择具有最高优先级的任务，并使其进入运行态。如果被选中的优先级上具有不止一个任务，调度器会让这些任务轮流执行。</strong><br>要能够选择下一个运行的任务，调度器需要在每个时间片的结束时刻运行自己本身。一个称为<code>tick</code>中断的周期性中断用于此目的。时间片的长度通过心跳中断的频率进行设定，心跳中断频率由<code>FreeRTOSConfig.h</code>中的编译时配置常量<code>configTICK_RATE_HZ</code>进行配置。<br>需要说明的是，FreeRTOS API 函数调用中指定的时间总是以心跳中断为单位（通常的提法为心跳“ticks”）。常量<code>portTICK_RATE_MS</code>用于将以心跳<code>tick</code>为单位的时间值转化为以毫秒为单位的时间值。<strong>有效精度依赖于系统心跳频率</strong>。<br><img src="/img/postpages/freeRTOS/1.jpg"><br>心跳计数(tick count)值表示的是从调度器启动开始，心跳中断的总数，并假定心跳计数器不会溢出。用户程序在指定延迟周期时不必考虑心跳计数溢出问题，因为时间连贯性在内核中进行管理。<br>上图中红色的线段表时内核本身在运行。黑色箭头表示任务到中断，中断再到另一个任务的执行顺序。  </p>
<h2 id="扩充“非运行态”"><a href="#扩充“非运行态”" class="headerlink" title="扩充“非运行态”"></a>扩充“非运行态”</h2><p>为了使我们的任务切实有用，我们需要通过某种方式来进行事件驱动。一个事件驱动任务只会在事件发生后触发工作(处理)，而在事件没有发生时是不能进入运行态的。调度器总是选择所有能够进入运行态的任务中具有最高优先级的任务。一个高优先级但不能够运行的任务意味着不会被调度器选中，而代之以另一个优先级虽然更低但能够运行的任务。因此，<strong>采用事件驱动任务的意义就在于任务可以被创建在许多不同的优先级上，并且最高优先级任务不会把所有的低优先级任务饿死。</strong>  </p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul>
<li>阻塞状态<br>  如果一个任务正在等待某个事件，则称这个任务处于“**阻塞态(blocked)**”。阻塞态是非运行态的一个子状态。<br>  任务可以进入阻塞态以等待以下两种不同类型的事件：<ol>
<li>定时(时间相关)事件：这类事件可以是延迟到期或是绝对时间到点。比如说某个任务可以进入阻塞态以延迟 10ms。</li>
<li>同步事件：源于其它任务或中断的事件。比如说，某个任务可以进入阻塞态以等待队列中有数据到来。<br>  <strong>任务可以在进入阻塞态以等待同步事件时指定一个等待超时时间，这样可以有效地实现阻塞状态下同时等待两种类型的事件</strong>。例如某个任务可以等待队列中有数据到来，但最多只等 10ms。如果 10ms 内有数据到来，或是 10ms 过去了还没有数据到来，这两种情况下该任务都将退出阻塞态。</li>
</ol>
</li>
<li>挂起状态<br>  “<strong>挂起(suspended)<strong>”也是非运行状态的子状态。</strong>处于挂起状态的任务对调度器而言是不可见的。</strong></li>
<li>就绪状态<br>  如果任务处于非运行状态，但既没有阻塞也没有挂起，则这个任务处于就绪(ready，准备或就绪)状态。处于就绪态的任务能够被运行，但只是“准备(ready)”运行，而当前尚未运行。</li>
</ul>
<h3 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h3><img src="/img/postpages/freeRTOS/2.jpg">  

<h3 id="阻塞态实现延迟"><a href="#阻塞态实现延迟" class="headerlink" title="阻塞态实现延迟"></a>阻塞态实现延迟</h3><p>使用空循环即不停地查询并递增一个循环计数直至计到某个指定值，会一直保持在运行态中执行空循环，可能将其它任务饿死。在查询过程中，任务实际上并没有做任何有意义的事情，但它依然会耗尽所有处理时间，对处理器周期造成浪费。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void vTaskDelay(portTickType xTicksToDelay);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>xTicksToDelay</code></td>
<td>延迟多少个心跳周期。调用该延迟函数的任务将进入阻塞态，经延迟指定的心跳周期数后，再转移到就绪态。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void vTaskDelayUntil( portTickType * pxPreviousWakeTime, portTickType xTimeIncrement ); </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>pxPreviousWakeTime</code></td>
<td>此参数用于实现某个任务以固定频率周期性执行。这种情况下<code>pxPreviousWakeTime</code>保存了任务上一次离开阻塞态(被唤醒)的时刻。这个时刻被用作一个参考点来计算该任务下一次离开阻塞态的时刻。</td>
</tr>
<tr>
<td><code>xTimeIncrement</code></td>
<td>用于实现某个任务以固定频率周期性执行，这个频率就是由<code>xTimeIncrement</code>指定。<code>xTimeIncrement</code>的单位是心跳周期，可以使用常量<code>portTICK_RATE_MS</code>将毫秒转换为心跳周期。</td>
</tr>
</tbody></table>
<ul>
<li><code>vTaskDelay()</code>的参数用来指定任务在调用<code>vTaskDelay()</code>到切出阻塞态整个过程包含多少个心跳周期。任务保持在阻塞态的时间量由<code>vTaskDelay()</code>的入口参数指定，但任务离开阻塞态的时刻实际上是相对于<code>vTaskDelay()</code>被调用那一刻的。  </li>
<li><code>vTaskDelayUntil()</code>的参数就是用来指定任务离开阻塞态进入就绪态那一刻的精确心跳计数值。可以用于实现一个固定执行周期的需求(当你需要让你的任务以固定频率周期性执行的时候)。**由于调用此函数的任务解除阻塞的时间是绝对时刻，比起相对于调用时刻的相对时间更精确(即比调用<code>vTaskDelay()</code>可以实现更精确的周期性)**。</li>
</ul>
<h2 id="空闲任务与空闲任务钩子函数"><a href="#空闲任务与空闲任务钩子函数" class="headerlink" title="空闲任务与空闲任务钩子函数"></a>空闲任务与空闲任务钩子函数</h2><h3 id="空闲任务"><a href="#空闲任务" class="headerlink" title="空闲任务"></a>空闲任务</h3><p>当创建的任务大部份时间都处于阻塞态时，这种状态下所有的任务都不可运行，所以也不能被调度器选中。<br>但处理器总是需要代码来执行，所以至少要有一个任务处于运行态。为了保证这一点，当调用<code>vTaskStartScheduler()</code>时，调度器会自动创建一个空闲任务。空闲任务是一个非常短小的循环，总是可以运行。<br>空闲任务拥有最低优先级(优先级 0)以保证其不会妨碍具有更高优先级的应用任务进入运行态。运行在最低优先级可以保证一旦有更高优先级的任务进入就绪态，空闲任务就会立即切出运行态。  </p>
<h3 id="空闲任务钩子函数"><a href="#空闲任务钩子函数" class="headerlink" title="空闲任务钩子函数"></a>空闲任务钩子函数</h3><p>通过空闲任务钩子函数(或称回调，hook, or call-back)，可以直接在空闲任务中添加应用程序相关的功能。空闲任务钩子函数会被空闲任务每循环一次就自动调用一次。<br>通常空闲任务钩子函数被用于：</p>
<ul>
<li>执行低优先级，后台或需要不停处理的功能代码。</li>
<li>测试处系统处理裕量(空闲任务只会在所有其它任务都不运行时才有机会执行，所以测量出空闲任务占用的处理时间就可以清楚的知道系统有多少富余的处理时间)。</li>
<li>将处理器配置到低功耗模式，提供一种自动省电方法，使得在没有任何应用功能需要处理的时候，系统自动进入省电模式。</li>
</ul>
<h3 id="空闲任务钩子函数的实现限制"><a href="#空闲任务钩子函数的实现限制" class="headerlink" title="空闲任务钩子函数的实现限制"></a>空闲任务钩子函数的实现限制</h3><p>空闲任务钩子函数必须遵从以下规则:</p>
<ol>
<li><strong>绝不能阻或挂起</strong>。空闲任务只会在其它任务都不运行时才会被执行(除非有应用任务共享空闲任务优先级)。以任何方式阻塞空闲任务都可能导致没有任务能够进入运行态</li>
<li><strong>如果应用程序用到了 <code>vTaskDelete()</code>函数，则空闲钩子函数必须能够尽快返回</strong>。因为在任务被删除后，空闲任务负责回收内核资源。如果空闲任务一直运行在钩子函数中，则无法进行回收工作。</li>
</ol>
<h3 id="空闲任务钩子函数原型"><a href="#空闲任务钩子函数原型" class="headerlink" title="空闲任务钩子函数原型"></a>空闲任务钩子函数原型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* 空闲钩子函数必须命名为vApplicationIdleHook(),无参数也无返回值。 */</span><br><span class="line">void vApplicationIdleHook( void )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="任务优先级-1"><a href="#任务优先级-1" class="headerlink" title="任务优先级"></a>任务优先级</h2><h3 id="改变优先级"><a href="#改变优先级" class="headerlink" title="改变优先级"></a>改变优先级</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority ); </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>pxTask</code></td>
<td>被修改优先级的任务句柄。任务可以通过传入 NULL 值来修改自己的优先级。</td>
</tr>
<tr>
<td><code>uxNewPriority</code></td>
<td>目标任务将被设置到哪个优先级上。</td>
</tr>
</tbody></table>
<h3 id="查询优先级"><a href="#查询优先级" class="headerlink" title="查询优先级"></a>查询优先级</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask );</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>pxTask</code></td>
<td>被修改优先级的任务句柄。任务可以通过传入 NULL 值来查询自己的优先级。</td>
</tr>
<tr>
<td><code>返回值</code></td>
<td>被查询任务的当前优先级。</td>
</tr>
</tbody></table>
<h2 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h2><p>任务被删除后就不复存在，也不会再进入运行态。空闲任务的责任是要将分配给已删除任务的内存释放掉。因此有一点很重要，那就是使用<code>vTaskDelete()</code>函数的任务千万不能把空闲任务的执行时间饿死。<br>需要说明一点，<strong>只有内核为任务分配的内存空间才会在任务被删除后自动回收。任务自己占用的内存或资源需要由应用程序自己显式地释放。</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void vTaskDelete( xTaskHandle pxTaskToDelete );</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>pxTaskToDelete</code></td>
<td>被删除任务的句柄.任务可以通过传入 NULL 值来删除自己。</td>
</tr>
</tbody></table>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="优先级抢占式调度"><a href="#优先级抢占式调度" class="headerlink" title="优先级抢占式调度"></a>优先级抢占式调度</h3><ul>
<li>每个任务都赋予了一个优先级。</li>
<li>每个任务都可以存在于一个或多个状态。</li>
<li>在任何时候都只有一个任务可以处于运行状态。</li>
<li>调度器总是在所有处于就绪态的任务中选择具有最高优先级的任务来执行。</li>
</ul>
<p>这种类型的调度方案被称为“<strong>固定优先级抢占式调度</strong>”。所谓“固定优先级”是指每个任务都被赋予了一个优先级，这个优先级不能被内核本身改变(只能被任务修改)。“抢占式”是指当任务进入就绪态或是优先级被改变时，如果处于运行态的任务优先级更低，则该任务总是抢占当前运行的任务。  </p>
<h3 id="选择任务优先级"><a href="#选择任务优先级" class="headerlink" title="选择任务优先级"></a>选择任务优先级</h3><p>作为一种通用规则，完成硬实时功能的任务优先级会高于完成软件时功能任务的优先级。但其它一些因素，比如执行时间和处理器利用率，都必须纳入考虑范围，以保证应用程序不会超过硬实时的需求限制。<br><strong>单调速率调度</strong>(Rate Monotonic Scheduling, RMS)是一种常用的优先级分配技术。其根据任务周期性执行的速率来分配一个唯一的优先级。<strong>具有最高周期执行频率的任务赋予高最优先级；具有最低周期执行频率的任务赋予最低优先级</strong>。这种优先级分配方式被证明了可以最大化整个应用程序的可调度性(schedulability)，但是运行时间不定以及并非所有任务都具有周期性，会使得对这种方式的全面计算变得相当复杂。  </p>
<h2 id="任务堆栈设置"><a href="#任务堆栈设置" class="headerlink" title="任务堆栈设置"></a>任务堆栈设置</h2><h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>xTask</code></td>
<td>被查询任务的句柄</td>
</tr>
<tr>
<td><code>返回值</code></td>
<td><strong>任务栈空间的实际使用量会随着任务执行和中断处理过程上下浮动</strong>。函数返回从任务启动执行开始的运行历史中，栈空间具有的<strong>最小剩余量</strong>。任务可以通过传入 NULL 值来查询自己的栈空间大小。这个值即是栈空间使用达到最深时的剩下的未使用的栈空间。这个值越是接近 0，则这个任务就越是离栈溢出不远了。</td>
</tr>
</tbody></table>
<h2 id="看门狗"><a href="#看门狗" class="headerlink" title="看门狗"></a>看门狗</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ESP-IDF 支持以下类型的看门狗定时器：</p>
<ul>
<li>中断看门狗定时器 (IWDT)</li>
<li>任务看门狗定时器 (TWDT)</li>
</ul>
<p>中断看门狗负责确保 ISR（中断服务程序）不被长时间阻塞，TWDT 负责检测任务长时间运行而不让步的情况。</p>
<h3 id="中断看门狗定时器-IWDT"><a href="#中断看门狗定时器-IWDT" class="headerlink" title="中断看门狗定时器 (IWDT)"></a>中断看门狗定时器 (IWDT)</h3><p>IWDT 的目的是，确保中断服务例程 (ISR) 运行不会受到长时间阻塞（即 IWDT 超时）。阻塞 ISR 及时运行会增加 ISR 延迟，也会阻止任务切换（因为任务切换是从 ISR 执行的）。阻止 ISR 运行的事项包括：</p>
<ul>
<li>禁用中断</li>
<li>临界区（也会禁用中断）</li>
<li>其他相同或更高优先级的 ISR，在完成前会阻止相同或较低优先级的 ISR</li>
</ul>
<p>当 IWDT 超时后，默认操作是调用紧急处理程序 (Panic Handler)，并显示 出错原因（ <code>Interrupt wdt timeout on CPU0</code> 或 <code>Interrupt wdt timeout on CPU1</code>，视情况而定）。根据紧急处理程序的配置行为（参见 CONFIG_ESP_SYSTEM_PANIC），用户可通过回溯、OpenOCD、gdbstub 等来调试 IWDT 超时问题，也可以重置芯片（这在生产环境中可能是首选）。</p>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>如果 IWDT 超时是中断或临界区运行超时导致的，可以考虑重写代码：</p>
<ul>
<li>临界区应尽可能短。任何非关键的代码或计算都应放在临界区外。</li>
<li>中断处理程序也应尽可能减少计算量。考虑让 ISR 使用队列向任务推送数据，从而将计算推迟到任务中进行。</li>
</ul>
<p>临界区或中断处理程序都不应阻塞其他事件。如果不能或不希望通过更改代码减少处理时间，可以通过设置  <code>CONFIG_ESP_INT_WDT_TIMEOUT_MS</code> 延长超时时间。  </p>
<h3 id="任务看门狗定时器-TWDT"><a href="#任务看门狗定时器-TWDT" class="headerlink" title="任务看门狗定时器 (TWDT)"></a>任务看门狗定时器 (TWDT)</h3><p>任务看门狗定时器 (TWDT) 用于监视特定任务，确保任务在配置的超时时间内执行。TWDT 主要监视每个 CPU 的空闲任务，但其他任务也可以订阅 TWDT 监视。通过监视每个 CPU 的空闲任务，TWDT 可以检测到任务长时间运行没有让出的情况。这可能表明代码编写不当，在外设上自旋循环，或者任务陷入了无限循环。<br>TWDT 是基于定时器组 0 中的硬件看门狗定时器构建的。超时发生时会触发中断。<br>可以在用户代码中定义函数<code>esp_task_wdt_isr_user_handler</code>来接收超时事件，并扩展默认行为。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用看门狗前先引入头文件<code>#include &quot;esp_task_wdt.h&quot;</code>，调用以下函数，用 TWDT 监视任务：</p>
<ul>
<li><code>esp_task_wdt_add()</code> 为其他任务订阅 TWDT。</li>
<li><code>订阅后，应从任务中调用</code> esp_task_wdt_reset() 来喂 TWDT。</li>
<li><code>esp_task_wdt_delete()</code> 可以取消之前订阅的任务。</li>
<li><code>esp_task_wdt_init()</code> 初始化 TWDT 并订阅空闲任务。</li>
<li><code>esp_task_wdt_deinit()</code>取消订阅空闲任务并反初始化 TWDT。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://wzx046.github.io">Star</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://wzx046.github.io/post/51/">http://wzx046.github.io/post/51/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://wzx046.github.io" target="_blank">Star</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ESP32/">ESP32</a><a class="post-meta__tags" href="/tags/freeRTOS/">freeRTOS</a></div><div class="post_share"><div class="social-share" data-image="/img/num/10.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/52/"><img class="prev-cover" src="/img/num/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ESPIDF-系统启动流程</div></div></a></div><div class="next-post pull-right"><a href="/post/50/"><img class="next-cover" src="/img/num/9.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ESP-IDF + VScode 开发环境搭建BUG</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/53/" title="FreeRTOS实时内核指南——队列管理"><img class="cover" src="/img/num/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-06</div><div class="title">FreeRTOS实时内核指南——队列管理</div></div></a></div><div><a href="/post/56/" title="FreeRTOS实时内核指南——资源管理"><img class="cover" src="/img/num/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-25</div><div class="title">FreeRTOS实时内核指南——资源管理</div></div></a></div><div><a href="/post/52/" title="ESPIDF-系统启动流程"><img class="cover" src="/img/num/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-08</div><div class="title">ESPIDF-系统启动流程</div></div></a></div><div><a href="/post/0/" title="ESP32上的FreeRTOS学习"><img class="cover" src="/img/num/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-17</div><div class="title">ESP32上的FreeRTOS学习</div></div></a></div><div><a href="/post/17/" title="ESP32上的FreeRTOS学习(2)"><img class="cover" src="/img/num/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-25</div><div class="title">ESP32上的FreeRTOS学习(2)</div></div></a></div><div><a href="/post/18/" title="ESP32上的FreeRTOS学习(3)"><img class="cover" src="/img/num/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-27</div><div class="title">ESP32上的FreeRTOS学习(3)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Star</div><div class="author-info__description">摸鱼ing</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/wzx046"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欸嘿~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#FreeRTOS%E5%AE%9E%E6%97%B6%E5%86%85%E6%A0%B8%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">FreeRTOS实时内核指南——任务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-number">1.1.</span> <span class="toc-text">概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%A4%9A%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.1.1.</span> <span class="toc-text">单任务与多任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%AE%9E%E6%97%B6%E4%B8%8E%E7%A1%AC%E5%AE%9E%E6%97%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">软实时与硬实时</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">任务函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%87%BD%E6%95%B0%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">典型的任务函数结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%87%BD%E6%95%B0%E5%86%85%E7%9A%84-static-%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">任务函数内的 static 变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">顶层任务状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.4.</span> <span class="toc-text">创建任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.5.</span> <span class="toc-text">任务优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%85%85%E2%80%9C%E9%9D%9E%E8%BF%90%E8%A1%8C%E6%80%81%E2%80%9D"><span class="toc-number">1.6.</span> <span class="toc-text">扩充“非运行态”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-number">1.6.1.</span> <span class="toc-text">状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE"><span class="toc-number">1.6.2.</span> <span class="toc-text">状态转移图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E6%80%81%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F"><span class="toc-number">1.6.3.</span> <span class="toc-text">阻塞态实现延迟</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E4%B8%8E%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">空闲任务与空闲任务钩子函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.7.1.</span> <span class="toc-text">空闲任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.2.</span> <span class="toc-text">空闲任务钩子函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%99%90%E5%88%B6"><span class="toc-number">1.7.3.</span> <span class="toc-text">空闲任务钩子函数的实现限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.7.4.</span> <span class="toc-text">空闲任务钩子函数原型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7-1"><span class="toc-number">1.8.</span> <span class="toc-text">任务优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.8.1.</span> <span class="toc-text">改变优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.8.2.</span> <span class="toc-text">查询优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.9.</span> <span class="toc-text">删除任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.10.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6"><span class="toc-number">1.10.1.</span> <span class="toc-text">优先级抢占式调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.10.2.</span> <span class="toc-text">选择任务优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%A0%86%E6%A0%88%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.11.</span> <span class="toc-text">任务堆栈设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-2"><span class="toc-number">1.11.1.</span> <span class="toc-text">函数原型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-number">1.12.</span> <span class="toc-text">看门狗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.12.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9C%8B%E9%97%A8%E7%8B%97%E5%AE%9A%E6%97%B6%E5%99%A8-IWDT"><span class="toc-number">1.12.2.</span> <span class="toc-text">中断看门狗定时器 (IWDT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-1"><span class="toc-number">1.12.3.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9C%8B%E9%97%A8%E7%8B%97%E5%AE%9A%E6%97%B6%E5%99%A8-TWDT"><span class="toc-number">1.12.4.</span> <span class="toc-text">任务看门狗定时器 (TWDT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.12.5.</span> <span class="toc-text">使用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/71/" title="esp32s3 开发指北"><img src="/img/num/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="esp32s3 开发指北"/></a><div class="content"><a class="title" href="/post/71/" title="esp32s3 开发指北">esp32s3 开发指北</a><time datetime="2025-02-21T10:07:00.000Z" title="发表于 2025-02-21 18:07:00">2025-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/70/" title="cygwin + autossh"><img src="/img/num/8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cygwin + autossh"/></a><div class="content"><a class="title" href="/post/70/" title="cygwin + autossh">cygwin + autossh</a><time datetime="2025-02-17T02:11:30.000Z" title="发表于 2025-02-17 10:11:30">2025-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/69/" title="fail2ban + 陷阱端口"><img src="/img/num/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="fail2ban + 陷阱端口"/></a><div class="content"><a class="title" href="/post/69/" title="fail2ban + 陷阱端口">fail2ban + 陷阱端口</a><time datetime="2025-02-06T08:02:01.000Z" title="发表于 2025-02-06 16:02:01">2025-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/68/" title="本地大模型接入QQ官方机器人"><img src="/img/num/6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="本地大模型接入QQ官方机器人"/></a><div class="content"><a class="title" href="/post/68/" title="本地大模型接入QQ官方机器人">本地大模型接入QQ官方机器人</a><time datetime="2025-01-29T15:04:10.000Z" title="发表于 2025-01-29 23:04:10">2025-01-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/65/" title="AI 换脸工具——FaceFusion"><img src="/img/num/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 换脸工具——FaceFusion"/></a><div class="content"><a class="title" href="/post/65/" title="AI 换脸工具——FaceFusion">AI 换脸工具——FaceFusion</a><time datetime="2025-01-10T11:24:17.000Z" title="发表于 2025-01-10 19:24:17">2025-01-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Star</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
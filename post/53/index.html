<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>FreeRTOS实时内核指南——队列管理 | Star</title><meta name="keywords" content="ESP32,freeRTOS"><meta name="author" content="Star"><meta name="copyright" content="Star"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="FreeRTOS实时内核指南——队列管理概览基于 FreeRTOS 的应用程序由一组独立的任务构成——每个任务都是具有独立权限的小程序。这些独立的任务之间很可能会通过相互通信以提供有用的系统功能。FreeRTOS 中所有的通信与同步机制都是基于队列实现的。   队列特性数据存储队列可以保存有限个具有确定长度的数据单元。队列可以保存的最大单元数目被称为队列的“深度”。在队列创建时需要设定其深度和每个">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS实时内核指南——队列管理">
<meta property="og:url" content="http://wzx046.github.io/post/53/index.html">
<meta property="og:site_name" content="Star">
<meta property="og:description" content="FreeRTOS实时内核指南——队列管理概览基于 FreeRTOS 的应用程序由一组独立的任务构成——每个任务都是具有独立权限的小程序。这些独立的任务之间很可能会通过相互通信以提供有用的系统功能。FreeRTOS 中所有的通信与同步机制都是基于队列实现的。   队列特性数据存储队列可以保存有限个具有确定长度的数据单元。队列可以保存的最大单元数目被称为队列的“深度”。在队列创建时需要设定其深度和每个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://wzx046.github.io/img/num/2.jpg">
<meta property="article:published_time" content="2023-12-06T03:38:50.000Z">
<meta property="article:modified_time" content="2024-04-05T12:28:40.422Z">
<meta property="article:author" content="Star">
<meta property="article:tag" content="ESP32">
<meta property="article:tag" content="freeRTOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wzx046.github.io/img/num/2.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://wzx046.github.io/post/53/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'FreeRTOS实时内核指南——队列管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-05 20:28:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/archive.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Star</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">FreeRTOS实时内核指南——队列管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-06T03:38:50.000Z" title="发表于 2023-12-06 11:38:50">2023-12-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-05T12:28:40.422Z" title="更新于 2024-04-05 20:28:40">2024-04-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ESPIDF/">ESPIDF</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="FreeRTOS实时内核指南——队列管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="FreeRTOS实时内核指南——队列管理"><a href="#FreeRTOS实时内核指南——队列管理" class="headerlink" title="FreeRTOS实时内核指南——队列管理"></a>FreeRTOS实时内核指南——队列管理</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>基于 FreeRTOS 的应用程序由一组独立的任务构成——每个任务都是具有独立权限的小程序。这些独立的任务之间很可能会通过相互通信以提供有用的系统功能。FreeRTOS 中所有的通信与同步机制都是基于队列实现的。  </p>
<h2 id="队列特性"><a href="#队列特性" class="headerlink" title="队列特性"></a>队列特性</h2><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>队列可以保存有限个具有确定长度的数据单元。队列可以<strong>保存的最大单元数目</strong>被称为队列的“深度”。在队列创建时需要设定其深度和每个单元的大小。<br>通常情况下，队列被作为 FIFO(先进先出)使用，即数据由队列尾写入，从队列首读出。当然，由队列首写入也是可能的。<br>往队列写入数据是通过字节拷贝把数据复制存储到队列中；从队列读出数据使得把队列中的数据拷贝删除。  </p>
<h3 id="可被多任务存取"><a href="#可被多任务存取" class="headerlink" title="可被多任务存取"></a>可被多任务存取</h3><p>队列是具有自己独立权限的内核对象，并不属于或赋予任何任务。所有任务都可以向同一队列写入和读出。一个队列由多方写入是经常的事，但由多方读出倒是很少遇到。  </p>
<h3 id="读队列时阻塞"><a href="#读队列时阻塞" class="headerlink" title="读队列时阻塞"></a>读队列时阻塞</h3><p>当某个任务试图读一个队列时，其可以指定一个<strong>阻塞超时时间</strong>。在这段时间中，如果队列为空，该任务将保持阻塞状态以等待队列数据有效。当其它任务或中断服务例程往其等待的队列中写入了数据，该任务将自动由阻塞态转移为就绪态。当等待的时间超过了指定的阻塞时间，即使队列中尚无有效数据，任务也会自动从阻塞态转移为就绪态。<br>由于队列可以被多个任务读取，所以对单个队列而言，也可能有多个任务处于阻塞状态以等待队列数据有效。这种情况下，一旦队列数据有效，只会有一个任务会被解除阻塞，这个任务就是所有等待任务中<strong>优先级最高</strong>的任务。而如果所有等待任务的优先级相同，那么被解除阻塞的任务将是<strong>等待最久</strong>的任务。  </p>
<h3 id="写队列时阻塞"><a href="#写队列时阻塞" class="headerlink" title="写队列时阻塞"></a>写队列时阻塞</h3><p>同读队列一样，任务也可以在写队列时指定一个阻塞超时时间。这个时间是当被写队列已满时，任务进入阻塞态以等待队列空间有效的最长时间。<br>由于队列可以被多个任务写入，所以对单个队列而言，也可能有多个任务处于阻塞状态以等待队列空间有效。这种情况下，一旦队列空间有效，只会有一个任务会被解除阻塞，这个任务就是所有等待任务中<strong>优先级最高的</strong>任务。而如果所有等待任务的优先级相同，那么被解除阻塞的任务将是<strong>等待最久</strong>的任务。  </p>
<h2 id="队列使用"><a href="#队列使用" class="headerlink" title="队列使用"></a>队列使用</h2><h3 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define xQueueCreate( uxQueueLength, uxItemSize )    xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )  </span><br><span class="line"></span><br><span class="line">QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,</span><br><span class="line">                                       const UBaseType_t uxItemSize,</span><br><span class="line">                                       const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>uxQueueLength</code></td>
<td>队列能够存储的最大单元数目，即队列深度。</td>
</tr>
<tr>
<td><code>uxItemSize</code></td>
<td>队列中数据单元的长度，以字节为单位。</td>
</tr>
<tr>
<td>返回值</td>
<td><code>NULL</code>表示没有足够的堆空间分配给队列而导致创建失败。非<code>NULL</code>值表示队列创建成功。此返回值应当保存下来，以作为操作此队列的句柄。</td>
</tr>
</tbody></table>
<h3 id="数据发送"><a href="#数据发送" class="headerlink" title="数据发送"></a>数据发送</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) \</span><br><span class="line">    xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )</span><br><span class="line"></span><br><span class="line">BaseType_t xQueueGenericSend( QueueHandle_t xQueue,</span><br><span class="line">                              const void * const pvItemToQueue,</span><br><span class="line">                              TickType_t xTicksToWait,</span><br><span class="line">                              const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>xQueue</code></td>
<td>目标队列的句柄。这个句柄即是调用<code>xQueueCreate()</code>创建该队列时的返回值</td>
</tr>
<tr>
<td><code>pvItemToQueue</code></td>
<td>发送数据的指针。其指向将要复制到目标队列中的数据单元。由于在创建队列时设置了队列中数据单元的长度，所以会从该指针指向的空间复制对应长度的数据到队列的存储区域。</td>
</tr>
<tr>
<td><code>xTicksToWait</code></td>
<td>阻塞超时时间。如果在发送时队列已满，这个时间即是任务处于阻塞态等待队列空间有效的最长等待时间。阻塞时间是以系统心跳周期为单位的，所以绝对时间取决于系统心跳频率。常量<code>portTICK_RATE_MS</code>可以用来把心跳时间单位转换为毫秒时间单位。</td>
</tr>
<tr>
<td>返回值</td>
<td>1.pdPASS—数据被成功发送到队列中。2.errQUEUE_FULL—队列已满而无法将数据写入。</td>
</tr>
</tbody></table>
<h3 id="数据接收"><a href="#数据接收" class="headerlink" title="数据接收"></a>数据接收</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t xQueueReceive( QueueHandle_t xQueue,</span><br><span class="line">                          void * const pvBuffer,</span><br><span class="line">                          TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>xQueue</code></td>
<td>目标队列的句柄。这个句柄即是调用<code>xQueueCreate()</code>创建该队列时的返回值</td>
</tr>
<tr>
<td><code>pvBuffer</code></td>
<td>接收缓存指针。其指向一段内存区域，用于接收从队列中拷贝来的数据。数据单元的长度在创建队列时就已经被设定，所以该指针指向的内存区域大小应当足够保存一个数据单元。</td>
</tr>
<tr>
<td><code>xTicksToWait</code></td>
<td>阻塞超时时间。如果在发送时队列已满，这个时间即是任务处于阻塞态等待队列空间有效的最长等待时间。阻塞时间是以系统心跳周期为单位的，所以绝对时间取决于系统心跳频率。常量<code>portTICK_RATE_MS</code>可以用来把心跳时间单位转换为毫秒时间单位。</td>
</tr>
<tr>
<td>返回值</td>
<td>1.<code>pdPASS</code>—成功地从队列中读到数据。2.<code>errQUEUE_FULL</code>—队列已空而没有读到任何数据。</td>
</tr>
</tbody></table>
<h3 id="查询数据个数"><a href="#查询数据个数" class="headerlink" title="查询数据个数"></a>查询数据个数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>xQueue</code></td>
<td>目标队列的句柄。这个句柄即是调用<code>xQueueCreate()</code>创建该队列时的返回值</td>
</tr>
<tr>
<td>返回值</td>
<td>当前队列中保存的数据单元个数。返回 0 表明队列为空。</td>
</tr>
</tbody></table>
<h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;freertos/FreeRTOS.h&quot;</span><br><span class="line">#include &quot;freertos/task.h&quot;</span><br><span class="line">#include &quot;../build/config/sdkconfig.h&quot;</span><br><span class="line">#include &quot;freertos/queue.h&quot;</span><br><span class="line"></span><br><span class="line">void sendTask(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t QueueHandle;</span><br><span class="line">    QueueHandle = (QueueHandle_t) pvParam;</span><br><span class="line">    BaseType_t state;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        state = xQueueSend(QueueHandle, &amp;temp, 0);</span><br><span class="line">        if(state != pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;send fail\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            printf(&quot;send success\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        temp++;</span><br><span class="line">        vTaskDelay(1000 / portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void receiveTask(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t QueueHandle;</span><br><span class="line">    QueueHandle = (QueueHandle_t) pvParam;</span><br><span class="line">    BaseType_t state; </span><br><span class="line">    int buffer = 0;  </span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(uxQueueMessagesWaiting(QueueHandle) != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            state = xQueueReceive(QueueHandle, &amp;buffer, 0);</span><br><span class="line">            if(state != pdPASS)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;receive fail\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                printf(&quot;receive %d\n&quot;, buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            printf(&quot;no data&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(1000 / portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void app_main(void)</span><br><span class="line">&#123;</span><br><span class="line">    TaskHandle_t MyHandle1 = NULL;//创造一个TaskHandle_t类型的变量;</span><br><span class="line">    TaskHandle_t MyHandle2 = NULL;//创造一个TaskHandle_t类型的变量;</span><br><span class="line"></span><br><span class="line">    QueueHandle_t QueueHandle;</span><br><span class="line">    QueueHandle = xQueueCreate(10, sizeof(int));</span><br><span class="line">    if(QueueHandle != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Create queue success\n&quot;);</span><br><span class="line">        xTaskCreate(sendTask, &quot;sendTask&quot;, 2048, (void *)QueueHandle, 1, MyHandle1);//创建任务函数</span><br><span class="line">        xTaskCreate(receiveTask, &quot;receiveTask&quot;, 2048, (void *)QueueHandle, 1, MyHandle2);//创建任务函数</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Create queue fail\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传递结构体"><a href="#传递结构体" class="headerlink" title="传递结构体"></a>传递结构体</h3><p>一个任务从单个队列中接收来自多个发送源的数据是经常的事。通常接收方收到数据后，需要知道数据的来源，并根据数据的来源决定下一步如何处理。一个简单的方式就是利用队列传递结构体，结构体成员中就包含了数据信息和来源信息。<br>修改上述代码为传递结构体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;freertos/FreeRTOS.h&quot;</span><br><span class="line">#include &quot;freertos/task.h&quot;</span><br><span class="line">#include &quot;../build/config/sdkconfig.h&quot;</span><br><span class="line">#include &quot;freertos/queue.h&quot;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t id;</span><br><span class="line">    int data; </span><br><span class="line">&#125;xData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void sendTask(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t QueueHandle;</span><br><span class="line">    QueueHandle = (QueueHandle_t) pvParam;</span><br><span class="line">    BaseType_t state;</span><br><span class="line">    xData sendData = &#123;0 , 100&#125;;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        state = xQueueSend(QueueHandle, &amp;sendData, 0);</span><br><span class="line">        if(state != pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;send fail\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            printf(&quot;send success\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sendData.id = sendData.id + 1;</span><br><span class="line">        sendData.data = sendData.data + 50;</span><br><span class="line">        vTaskDelay(1000 / portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void receiveTask(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t QueueHandle;</span><br><span class="line">    QueueHandle = (QueueHandle_t) pvParam;</span><br><span class="line">    BaseType_t state; </span><br><span class="line">    xData buffer = &#123;0, 0&#125;; </span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(uxQueueMessagesWaiting(QueueHandle) != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            state = xQueueReceive(QueueHandle, &amp;buffer, 0);</span><br><span class="line">            if(state != pdPASS)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;receive fail\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                printf(&quot;id = %d\n&quot;, buffer.id);</span><br><span class="line">                printf(&quot;data = %d\n&quot;, buffer.data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            printf(&quot;no data&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(1000 / portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void app_main(void)</span><br><span class="line">&#123;</span><br><span class="line">    TaskHandle_t MyHandle1 = NULL;//创造一个TaskHandle_t类型的变量;</span><br><span class="line">    TaskHandle_t MyHandle2 = NULL;//创造一个TaskHandle_t类型的变量;</span><br><span class="line"></span><br><span class="line">    QueueHandle_t QueueHandle;</span><br><span class="line">    QueueHandle = xQueueCreate(10, sizeof(xData));</span><br><span class="line">    if(QueueHandle != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Create queue success\n&quot;);</span><br><span class="line">        xTaskCreate(sendTask, &quot;sendTask&quot;, 2048, (void *)QueueHandle, 1, MyHandle1);//创建任务函数</span><br><span class="line">        xTaskCreate(receiveTask, &quot;receiveTask&quot;, 2048, (void *)QueueHandle, 1, MyHandle2);//创建任务函数</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Create queue fail\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工作于大型数据单元"><a href="#工作于大型数据单元" class="headerlink" title="工作于大型数据单元"></a>工作于大型数据单元</h2><p>如果队列存储的数据单元尺寸较大，那最好是利用队列来<strong>传递数据的指针</strong>而不是对数据本身在队列上一字节一字节地拷贝进或拷贝出。传递指针无论是在处理速度上还是内存空间利用上都更有效。但是，当你利用队列传递指针时，一定要十分小心地做到以下两点：</p>
<ul>
<li>指针指向的内存空间的所有权必须明确<br>  当任务间通过指针共享内存时，应该从根本上保证所不会有任意两个任务同时修改共享内存中的数据，或是以其它行为方式使得共享内存数据无效或产生一致性问题。原则上，共享内存在其指针发送到队列之前，其内容只允许被发送任务访问；共享内存指针从队列中被读出之后，其内容亦只允许被接收任务访问。</li>
<li>指针指向的内存空间必须有效<br>  如果指针指向的内存空间是动态分配的，只应该有一个任务负责对其进行内存释放。当这段内存空间被释放之后，就不应该有任何一个任务再访问这段空间。</li>
</ul>
<p>切忌用指针访问任务栈上分配的空间。因为当栈帧发生改变后，栈上的数据将不再有效。</p>
<h2 id="多进单出"><a href="#多进单出" class="headerlink" title="多进单出"></a>多进单出</h2><p>多个任务把数据写入一个队列，一个任务进行读。设置写入的任务级别为同级别，读任务的优先级别要比写任务高一级别。  </p>
<ul>
<li>不推荐这种方式：容易造成系统工作混乱。最好的工作方式是一个队列只有一个写操作，可以有多个读操作，但是写操作只能有一个。<strong>建议使用队列集合</strong>。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">void sendTask1(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t QueueHandle;</span><br><span class="line">    QueueHandle = (QueueHandle_t) pvParam;</span><br><span class="line">    BaseType_t state;</span><br><span class="line">    xData sendData = &#123;0 , 111&#125;;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        state = xQueueSend(QueueHandle, &amp;sendData, 0);</span><br><span class="line">        vTaskDelay(1000 / portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sendTask2(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t QueueHandle;</span><br><span class="line">    QueueHandle = (QueueHandle_t) pvParam;</span><br><span class="line">    BaseType_t state;</span><br><span class="line">    xData sendData = &#123;1 , 999&#125;;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        state = xQueueSend(QueueHandle, &amp;sendData, 0);</span><br><span class="line">        vTaskDelay(1000 / portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sendTask3(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t QueueHandle;</span><br><span class="line">    QueueHandle = (QueueHandle_t) pvParam;</span><br><span class="line">    BaseType_t state;</span><br><span class="line">    xData sendData = &#123;2 , 555&#125;;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        state = xQueueSend(QueueHandle, &amp;sendData, 0);</span><br><span class="line">        vTaskDelay(1000 / portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void receiveTask(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t QueueHandle;</span><br><span class="line">    QueueHandle = (QueueHandle_t) pvParam;</span><br><span class="line">    BaseType_t state; </span><br><span class="line">    xData buffer = &#123;0, 0&#125;; </span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        state = xQueueReceive(QueueHandle, &amp;buffer, portMAX_DELAY);</span><br><span class="line">        if(state != pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;receive fail\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;id = %d&quot;, buffer.id);</span><br><span class="line">                printf(&quot;    data = %d\n&quot;, buffer.data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void app_main(void)</span><br><span class="line">&#123;</span><br><span class="line">    TaskHandle_t MyHandle1 = NULL;//创造一个TaskHandle_t类型的变量;</span><br><span class="line">    TaskHandle_t MyHandle2 = NULL;//创造一个TaskHandle_t类型的变量;</span><br><span class="line"></span><br><span class="line">    QueueHandle_t QueueHandle;</span><br><span class="line">    QueueHandle = xQueueCreate(10, sizeof(xData));</span><br><span class="line">    if(QueueHandle != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Create queue success\n&quot;);</span><br><span class="line">        xTaskCreate(sendTask1, &quot;sendTask&quot;, 2048, (void *)QueueHandle, 1, MyHandle1);//创建任务函数</span><br><span class="line">        xTaskCreate(sendTask2, &quot;sendTask&quot;, 2048, (void *)QueueHandle, 1, MyHandle1);//创建任务函数</span><br><span class="line">        xTaskCreate(sendTask3, &quot;sendTask&quot;, 2048, (void *)QueueHandle, 1, MyHandle1);//创建任务函数</span><br><span class="line">        xTaskCreate(receiveTask, &quot;receiveTask&quot;, 2048, (void *)QueueHandle, 2, MyHandle2);//创建任务函数</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Create queue fail\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="队列集合"><a href="#队列集合" class="headerlink" title="队列集合"></a>队列集合</h2><p>任务通信过程中，如果消息类型不同，使用一个队列实现比较麻烦。通过队列集合，可以对多个队列以及信号量进行监听，只要有一个消息到来，就可以让任务退出阻塞状态。  </p>
<ul>
<li>多个队列，但是每个队列只有一个写操作，一个读操作(读取所有队列)</li>
</ul>
<h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) PRIVILEGED_FUNCTION;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>uxEventQueueLength</code></td>
<td>Queue sets store events that occur on the queues and semaphores contained in the set.  uxEventQueueLength specifies the maximum number of events that can be queued at once.  To be absolutely certain that events are not lost uxEventQueueLength should be set to the total sum of the length of the queues added to the set, where binary semaphores and mutexes have a length of 1, and counting semaphores have a length set by their maximum count value.</td>
</tr>
<tr>
<td><code>return</code></td>
<td>If the queue set is created successfully then a handle to the created queue set is returned.  Otherwise NULL is returned.</td>
</tr>
</tbody></table>
<h3 id="添加队列到集合"><a href="#添加队列到集合" class="headerlink" title="添加队列到集合"></a>添加队列到集合</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,</span><br><span class="line">                           QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>xQueueOrSemaphore</code></td>
<td>The handle of the queue or semaphore being added to the queue set (cast to an QueueSetMemberHandle_t type)</td>
</tr>
<tr>
<td><code>xQueueSet</code></td>
<td>The handle of the queue set to which the queue or semaphore is being added.</td>
</tr>
<tr>
<td><code>return</code></td>
<td>If the queue or semaphore was successfully added to the queue set then pdPASS is returned.  If the queue could not be successfully added to the queue set because it is already a member of a different queue set then pdFAIL is returned.</td>
</tr>
</tbody></table>
<h3 id="从集合中选择数据"><a href="#从集合中选择数据" class="headerlink" title="从集合中选择数据"></a>从集合中选择数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet,</span><br><span class="line">                                            const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>xQueueSet</code></td>
<td>The queue set on which the task will (potentially) block.</td>
</tr>
<tr>
<td><code>xTicksToWait</code></td>
<td>The maximum time, in ticks, that the calling task will remain in the Blocked state (with other tasks executing) to wait for a member of the queue set to be ready for a successful queue read or semaphore take operation</td>
</tr>
<tr>
<td><code>return</code></td>
<td>return the handle of a queue (cast to a QueueSetMemberHandle_t type) contained in the queue set that contains data,or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained in the queue set that is available, or NULL if no such queue or semaphore exists before before the specified block time expires.</td>
</tr>
</tbody></table>
<h3 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;freertos/FreeRTOS.h&quot;</span><br><span class="line">#include &quot;freertos/task.h&quot;</span><br><span class="line">#include &quot;../build/config/sdkconfig.h&quot;</span><br><span class="line">#include &quot;freertos/queue.h&quot;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t id;</span><br><span class="line">    int data; </span><br><span class="line">&#125;xData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void sendTask1(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t QueueHandle;</span><br><span class="line">    QueueHandle = (QueueHandle_t) pvParam;</span><br><span class="line">    BaseType_t state;</span><br><span class="line">    xData sendData = &#123;1 , 111&#125;;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        state = xQueueSend(QueueHandle, &amp;sendData, 0);</span><br><span class="line">        vTaskDelay(1000 / portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sendTask2(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t QueueHandle;</span><br><span class="line">    QueueHandle = (QueueHandle_t) pvParam;</span><br><span class="line">    BaseType_t state;</span><br><span class="line">    xData sendData = &#123;2 , 222&#125;;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        state = xQueueSend(QueueHandle, &amp;sendData, 0);</span><br><span class="line">        vTaskDelay(1000 / portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sendTask3(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t QueueHandle;</span><br><span class="line">    QueueHandle = (QueueHandle_t) pvParam;</span><br><span class="line">    BaseType_t state;</span><br><span class="line">    xData sendData = &#123;3 , 333&#125;;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        state = xQueueSend(QueueHandle, &amp;sendData, 0);</span><br><span class="line">        vTaskDelay(1000 / portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void receiveTask(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    QueueSetHandle_t QueueHandle;</span><br><span class="line">    QueueHandle = (QueueSetHandle_t) pvParam;</span><br><span class="line">    QueueSetMemberHandle_t QueueSetData;</span><br><span class="line">    </span><br><span class="line">    BaseType_t state; </span><br><span class="line">    xData buffer = &#123;0, 0&#125;; </span><br><span class="line"></span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        QueueSetData = xQueueSelectFromSet(QueueHandle, portMAX_DELAY);  // 没有数据就一直等待</span><br><span class="line">        state = xQueueReceive(QueueSetData, &amp;buffer, portMAX_DELAY);</span><br><span class="line">        if(state != pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;receive fail\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;id = %d&quot;, buffer.id);</span><br><span class="line">                printf(&quot;    data = %d\n&quot;, buffer.data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void app_main(void)</span><br><span class="line">&#123;</span><br><span class="line">    TaskHandle_t MyHandle1 = NULL;//创造一个TaskHandle_t类型的变量;</span><br><span class="line">    TaskHandle_t MyHandle2 = NULL;//创造一个TaskHandle_t类型的变量;</span><br><span class="line"></span><br><span class="line">    QueueHandle_t QueueHandle1;</span><br><span class="line">    QueueHandle1 = xQueueCreate(10, sizeof(xData));</span><br><span class="line">    QueueHandle_t QueueHandle2;</span><br><span class="line">    QueueHandle2 = xQueueCreate(10, sizeof(xData));</span><br><span class="line">    QueueHandle_t QueueHandle3;</span><br><span class="line">    QueueHandle3 = xQueueCreate(10, sizeof(xData));</span><br><span class="line"></span><br><span class="line">    QueueSetHandle_t QueueSet;</span><br><span class="line">    QueueSet = xQueueCreateSet(10+10+10);</span><br><span class="line">    xQueueAddToSet(QueueHandle1, QueueSet);</span><br><span class="line">    xQueueAddToSet(QueueHandle2, QueueSet);</span><br><span class="line">    xQueueAddToSet(QueueHandle3, QueueSet);</span><br><span class="line">    if((QueueHandle1 != NULL) &amp;&amp; (QueueHandle2 != NULL) &amp;&amp; (QueueHandle3 != NULL))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Create queue success\n&quot;);</span><br><span class="line">        xTaskCreate(sendTask1, &quot;sendTask&quot;, 2048, (void *)QueueHandle1, 1, MyHandle1);//创建任务函数</span><br><span class="line">        xTaskCreate(sendTask2, &quot;sendTask&quot;, 2048, (void *)QueueHandle2, 1, MyHandle1);//创建任务函数</span><br><span class="line">        xTaskCreate(sendTask3, &quot;sendTask&quot;, 2048, (void *)QueueHandle3, 1, MyHandle1);//创建任务函数</span><br><span class="line">        xTaskCreate(receiveTask, &quot;receiveTask&quot;, 2048, (void *)QueueSet, 2, MyHandle2);//创建任务函数</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Create queue fail\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列邮箱"><a href="#队列邮箱" class="headerlink" title="队列邮箱"></a>队列邮箱</h2><p>邮箱是长度为1的队列，接收数据的任务或者中断ISR从这个邮箱中读取数据的时候，并不会将这个数据从邮箱中删除，它会一直保留，直到新的数据被写入到邮箱覆盖之前的数据。任何任务或者ISR都可以从这个邮箱中读取数据。  </p>
<ul>
<li>只有一个队列，一个任务写，多个任务读。</li>
</ul>
<h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define xQueueOverwrite( xQueue, pvItemToQueue ) \</span><br><span class="line">    xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )</span><br><span class="line"></span><br><span class="line">BaseType_t xQueueGenericSend( QueueHandle_t xQueue,</span><br><span class="line">                              const void * const pvItemToQueue,</span><br><span class="line">                              TickType_t xTicksToWait,</span><br><span class="line">                              const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>xQueue</code></td>
<td>目标队列的句柄。</td>
</tr>
<tr>
<td><code>pvItemToQueue</code></td>
<td>发送数据的指针。其指向将要复制到目标队列中的数据单元。由于在创建队列时设置了队列中数据单元的长度，所以会从该指针指向的空间复制对应长度的数据到队列的存储区域。</td>
</tr>
<tr>
<td>返回值</td>
<td>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</td>
</tr>
</tbody></table>
<h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t xQueuePeek( QueueHandle_t xQueue,</span><br><span class="line">                       void * const pvBuffer,</span><br><span class="line">                       TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>xQueue</code></td>
<td>目标队列的句柄。</td>
</tr>
<tr>
<td><code>pvBuffer</code></td>
<td>接收缓存指针。其指向一段内存区域，用于接收从队列中拷贝来的数据。数据单元的长度在创建队列时就已经被设定，所以该指针指向的内存区域大小应当足够保存一个数据单元。</td>
</tr>
<tr>
<td><code>xTicksToWait</code></td>
<td>阻塞超时时间。如果在发送时队列已满，这个时间即是任务处于阻塞态等待队列空间有效的最长等待时间。阻塞时间是以系统心跳周期为单位的，所以绝对时间取决于系统心跳频率。常量<code>portTICK_RATE_MS</code>可以用来把心跳时间单位转换为毫秒时间单位。</td>
</tr>
<tr>
<td>返回值</td>
<td>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.</td>
</tr>
</tbody></table>
<ul>
<li><code>xQueuePeek</code> 不会删除句柄里面的数据，所以第一次 <code>xQueuePeek</code> 开始就一直有数据，导致最后portMAX_DELAY参数没起作用。</li>
</ul>
<h3 id="使用案例-2"><a href="#使用案例-2" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;freertos/FreeRTOS.h&quot;</span><br><span class="line">#include &quot;freertos/task.h&quot;</span><br><span class="line">#include &quot;../build/config/sdkconfig.h&quot;</span><br><span class="line">#include &quot;freertos/queue.h&quot;</span><br><span class="line"></span><br><span class="line">void writeTask(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t MailBox;</span><br><span class="line">    MailBox = (QueueHandle_t) pvParam;</span><br><span class="line">    BaseType_t state;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        state = xQueueOverwrite(MailBox, &amp;temp);</span><br><span class="line">        if(state != pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;send fail\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            printf(&quot;send success\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        temp++;</span><br><span class="line">        vTaskDelay(5000 / portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void readTask1(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t MailBox;</span><br><span class="line">    MailBox = (QueueHandle_t) pvParam;</span><br><span class="line">    BaseType_t state; </span><br><span class="line">    int buffer = 0;  </span><br><span class="line"></span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        state = xQueuePeek(MailBox, &amp;buffer, 0);</span><br><span class="line">        if(state != pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;read fail\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            printf(&quot;read %d\n&quot;, buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(1000 / portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void readTask2(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t MailBox;</span><br><span class="line">    MailBox = (QueueHandle_t) pvParam;</span><br><span class="line">    BaseType_t state; </span><br><span class="line">    int buffer = 0;  </span><br><span class="line"></span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        state = xQueuePeek(MailBox, &amp;buffer, 0);</span><br><span class="line">        if(state != pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;read fail\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            printf(&quot;read %d\n&quot;, buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(1000 / portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void readTask3(void *pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    QueueHandle_t MailBox;</span><br><span class="line">    MailBox = (QueueHandle_t) pvParam;</span><br><span class="line">    BaseType_t state; </span><br><span class="line">    int buffer = 0;  </span><br><span class="line"></span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        state = xQueuePeek(MailBox, &amp;buffer, 0);</span><br><span class="line">        if(state != pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;read fail\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            printf(&quot;read %d\n&quot;, buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(1000 / portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void app_main(void)</span><br><span class="line">&#123;</span><br><span class="line">    TaskHandle_t MyHandle1 = NULL;//创造一个TaskHandle_t类型的变量;</span><br><span class="line">    TaskHandle_t MyHandle2 = NULL;//创造一个TaskHandle_t类型的变量;</span><br><span class="line"></span><br><span class="line">    QueueHandle_t MailBox;</span><br><span class="line">    MailBox = xQueueCreate(1, sizeof(int));</span><br><span class="line">    if(MailBox != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Create MailBox success\n&quot;);</span><br><span class="line">        xTaskCreate(writeTask, &quot;writeTask&quot;, 2048, (void *)MailBox, 1, MyHandle1);//创建任务函数</span><br><span class="line">        xTaskCreate(readTask1, &quot;readTask1&quot;, 2048, (void *)MailBox, 2, MyHandle2);//创建任务函数</span><br><span class="line">        xTaskCreate(readTask2, &quot;readTask2&quot;, 2048, (void *)MailBox, 2, MyHandle2);//创建任务函数</span><br><span class="line">        xTaskCreate(readTask3, &quot;readTask3&quot;, 2048, (void *)MailBox, 2, MyHandle2);//创建任务函数</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Create MailBox fail\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://wzx046.github.io">Star</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://wzx046.github.io/post/53/">http://wzx046.github.io/post/53/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://wzx046.github.io" target="_blank">Star</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ESP32/">ESP32</a><a class="post-meta__tags" href="/tags/freeRTOS/">freeRTOS</a></div><div class="post_share"><div class="social-share" data-image="/img/num/2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/54/"><img class="prev-cover" src="/img/num/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ESPIDF-通讯外设</div></div></a></div><div class="next-post pull-right"><a href="/post/52/"><img class="next-cover" src="/img/num/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ESPIDF-系统启动流程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/51/" title="FreeRTOS实时内核指南——任务管理"><img class="cover" src="/img/num/10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-07</div><div class="title">FreeRTOS实时内核指南——任务管理</div></div></a></div><div><a href="/post/56/" title="FreeRTOS实时内核指南——资源管理"><img class="cover" src="/img/num/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-25</div><div class="title">FreeRTOS实时内核指南——资源管理</div></div></a></div><div><a href="/post/52/" title="ESPIDF-系统启动流程"><img class="cover" src="/img/num/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-08</div><div class="title">ESPIDF-系统启动流程</div></div></a></div><div><a href="/post/0/" title="ESP32上的FreeRTOS学习"><img class="cover" src="/img/num/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-17</div><div class="title">ESP32上的FreeRTOS学习</div></div></a></div><div><a href="/post/17/" title="ESP32上的FreeRTOS学习(2)"><img class="cover" src="/img/num/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-25</div><div class="title">ESP32上的FreeRTOS学习(2)</div></div></a></div><div><a href="/post/18/" title="ESP32上的FreeRTOS学习(3)"><img class="cover" src="/img/num/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-27</div><div class="title">ESP32上的FreeRTOS学习(3)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Star</div><div class="author-info__description">摸鱼ing</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/wzx046"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欸嘿~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#FreeRTOS%E5%AE%9E%E6%97%B6%E5%86%85%E6%A0%B8%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">FreeRTOS实时内核指南——队列管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-number">1.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">队列特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">数据存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A2%AB%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%AD%98%E5%8F%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">可被多任务存取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E9%98%9F%E5%88%97%E6%97%B6%E9%98%BB%E5%A1%9E"><span class="toc-number">1.2.3.</span> <span class="toc-text">读队列时阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E9%98%9F%E5%88%97%E6%97%B6%E9%98%BB%E5%A1%9E"><span class="toc-number">1.2.4.</span> <span class="toc-text">写队列时阻塞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">队列使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97"><span class="toc-number">1.3.1.</span> <span class="toc-text">创建队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81"><span class="toc-number">1.3.2.</span> <span class="toc-text">数据发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">数据接收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0"><span class="toc-number">1.3.4.</span> <span class="toc-text">查询数据个数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.4.</span> <span class="toc-text">使用案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.4.1.</span> <span class="toc-text">传递结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E4%BA%8E%E5%A4%A7%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83"><span class="toc-number">1.5.</span> <span class="toc-text">工作于大型数据单元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E5%8D%95%E5%87%BA"><span class="toc-number">1.6.</span> <span class="toc-text">多进单出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E9%9B%86%E5%90%88"><span class="toc-number">1.7.</span> <span class="toc-text">队列集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88"><span class="toc-number">1.7.1.</span> <span class="toc-text">创建集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E9%98%9F%E5%88%97%E5%88%B0%E9%9B%86%E5%90%88"><span class="toc-number">1.7.2.</span> <span class="toc-text">添加队列到集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E9%9B%86%E5%90%88%E4%B8%AD%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE"><span class="toc-number">1.7.3.</span> <span class="toc-text">从集合中选择数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-1"><span class="toc-number">1.7.4.</span> <span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E9%82%AE%E7%AE%B1"><span class="toc-number">1.8.</span> <span class="toc-text">队列邮箱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.8.1.</span> <span class="toc-text">写入数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.8.2.</span> <span class="toc-text">读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-2"><span class="toc-number">1.8.3.</span> <span class="toc-text">使用案例</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/71/" title="esp32s3 开发指北"><img src="/img/num/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="esp32s3 开发指北"/></a><div class="content"><a class="title" href="/post/71/" title="esp32s3 开发指北">esp32s3 开发指北</a><time datetime="2025-02-21T10:07:00.000Z" title="发表于 2025-02-21 18:07:00">2025-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/70/" title="cygwin + autossh"><img src="/img/num/8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cygwin + autossh"/></a><div class="content"><a class="title" href="/post/70/" title="cygwin + autossh">cygwin + autossh</a><time datetime="2025-02-17T02:11:30.000Z" title="发表于 2025-02-17 10:11:30">2025-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/69/" title="fail2ban + 陷阱端口"><img src="/img/num/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="fail2ban + 陷阱端口"/></a><div class="content"><a class="title" href="/post/69/" title="fail2ban + 陷阱端口">fail2ban + 陷阱端口</a><time datetime="2025-02-06T08:02:01.000Z" title="发表于 2025-02-06 16:02:01">2025-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/68/" title="本地大模型接入QQ官方机器人"><img src="/img/num/6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="本地大模型接入QQ官方机器人"/></a><div class="content"><a class="title" href="/post/68/" title="本地大模型接入QQ官方机器人">本地大模型接入QQ官方机器人</a><time datetime="2025-01-29T15:04:10.000Z" title="发表于 2025-01-29 23:04:10">2025-01-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/65/" title="AI 换脸工具——FaceFusion"><img src="/img/num/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 换脸工具——FaceFusion"/></a><div class="content"><a class="title" href="/post/65/" title="AI 换脸工具——FaceFusion">AI 换脸工具——FaceFusion</a><time datetime="2025-01-10T11:24:17.000Z" title="发表于 2025-01-10 19:24:17">2025-01-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Star</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>